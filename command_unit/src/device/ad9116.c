/*!  \file 	dac.c
 *   \brief  
 *   \details  
 *
 *
 *
 */

/*includes==========================================================================================================*/
#include "ad9116.h"
#include "stm32f4xx_gpio_brd.h"
#include "stm32f4xx_spidac_brd.h"
#include "stm32f4xx_pwmdac_brd.h"
//#include <stm32f4xx_hal.h>

/*defines===========================================================================================================*/


/*types=============================================================================================================*/


/*prototypes========================================================================================================*/
//static void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);


/*variables=========================================================================================================*/
static	uint8_t				clock_timer_disabled = 1;		/* флаг указывающий работает или нет тактирующий таймер 1-выключен, 0-включен*/

/*code==============================================================================================================*/

uint8_t		verbuf = 0;

/*=============================================================================================================*/
/*!  \brief конфигурируем интерфейсы последовательный и параралельный для управлениея ЦАПом

     \return int
     \retval OK, ERROR
     \sa 
*/
/*=============================================================================================================*/
int     ad9116_open
    (
     int dac_index      /*!< [in] индекс цапа 0-3 */
     )
    {    
        /* конфигурирование ног паралелльной шины как выходов */
	    gpio_dac_open(dac_index);
    
        /* включение интерфейса SPI2 */
	    spi_dac_open(dac_index);    
	    gpio_dacspi_open(dac_index);
        
        /* включение тактирующего таймера */
	    if (clock_timer_disabled)
	    {
		    clock_timer_disabled = 0;
		    /* tim3 ch3 */
		    pwm_dac_open();		    
		    gpio_dacpwm_open();		    
		}
	    
//	    for (;;)
//	    {
//		    spi_dac_read(dac_index, AD9116_VERSION, &verbuf, 1, 1000);
//		    continue;		    
//	    }		    
//    
	    	    
	return OK;
    }



/*=============================================================================================================*/
/*!  \brief выключаем интерфейсы работаюшие с ЦАП

     \return int
     \retval OK, ERROR
     \sa 
*/
/*=============================================================================================================*/
int     ad9116_close
    (
     int dac_index      /*!< [in] индекс цапа 0-3 */
     )
    {    
    /**/
	gpio_dac_close(dac_index);
	gpio_dacspi_close(dac_index);
		    
    if (!clock_timer_disabled)
    {
	    gpio_dacpwm_close();
	    
	    clock_timer_disabled = 1;
    }
	    
	    
	    
    return OK;    
    }



/*=============================================================================================================*/
/*!  \brief  Запись цифровых данных в ЦАП

     \return int
     \retval OK, ERROR
     \sa 
*/
/*=============================================================================================================*/
int     ad9116_write_data
    (
     int                    dac_index,  /*!< [in] индекс цапа 0-3                           */
     enum AD9116_INTERFACE  interface,  /*!< [in] интерфейс по которому передаются данные   */
	 dac_values_t			data		/*!< [in] данные для выхода i и q ЦАПа			    */
	)
    {
    /**/
	    switch (interface)
	    {
	    case AD9116_SPI:   
		    {
					/* для мультиплексированных выходов */
			    spi_dac_write(dac_index, AD9116_AUXDAC_Q, (uint8_t*)&data.q, 2, 1000);
			    spi_dac_write(dac_index, AD9116_AUXDAC_I, (uint8_t*)&data.i, 2, 1000);
		    } break;
		    
	    case AD9116_PARALLEL:
		    {
			    if (dac_index & DAC_01) {
				    gpio_dac_write_01(data.i , data.q);
			    } else
			    if (dac_index & DAC_23) {
				    gpio_dac_write_23(data.i, data.q);
			    } else
			    if (dac_index & DAC_45) {
				    gpio_dac_write_45(data.i, data.q);
			    } else
			    if (dac_index & DAC_67) {
				    gpio_dac_write_67(data.i, data.q);
			    }
		    } break;
	    }
	    	    
    return OK;    
    }
    
/*=============================================================================================================*/
/*!  \brief запись последовательно во все ЦАП

     \return int
     \retval OK, ERROR
     \sa 
*/
/*=============================================================================================================*/
int     ad9116_write_parralel
    (
    int                    dac_index,  /*!< [in] индекс цапа 0-3                           */
	uint16_t               *data,	   /*!< [in] данные для выхода i ЦАПа				    */
	uint8_t                len		   /*!< [in] данные для выхода q ЦАПа    */
	)
{
	
	
	return OK;
}




/*=============================================================================================================*/
/*!  \brief Чтение данных с ЦАП

     \return int
     \retval OK, ERROR
     \sa 
*/
/*=============================================================================================================*/
uint8_t     ad9116_read_id
    (
     int                    dac_index   /*!< [in] индекс цапа 0-3                           */
     )
    {
	    uint8_t		id = 0;
    
	    for (;;)
	    {
		    spi_dac_read(DAC_01, AD9116_VERSION, &id, 1, 1000);		    
	    }
	    
		return id;    
    }
    

